## Local variables

local _bld
local _res
local _grn
local _blu
local _red
local _Blu
local _Red
local info
local _only_files
local _du_all_opt
local _nb_lines
local opt
local old_sort
local _du_arg
local _sort_arg
local _align
local _files
local size
local _size
local date
local hour
local file
local _file
local _len

## Colors

_bld=$(tput bold)
_res=$(tput sgr0)

_grn=$(tput setaf 2)
_blu=$(tput setaf 4)
_red=$(tput setaf 1)

_Blu=$(printf %s $_bld; tput setaf 4)
_Red=$(printf %s $_bld; tput setaf 1)

## Help

_help() {

# NB:
#    To get files only, a mixed output of both files and directories (du -a)
#    gets filtered. So with -f -n3, if the biggest 3 inodes are 2 directories
#    and one file, we get a single file despite using -n3
read -r -d $'\0' info << HELP
Usage:
   ${_bld}duu${_res}     ${_grn}# files & directories${_res}
   ${_bld}duu${_res} -f  ${_grn}# files only${_res}
   ${_bld}duu${_res} -d  ${_grn}# directories only${_res}
   ${_bld}duu${_res} -n${_bld}N${_res} ${_grn}# lines of output (${_bld}15${_res} ${_grn}by default)${_res}

Note: ${_bld}.${_res} is used by default but a different directory can also be specified
HELP

if (($1 == 0))
then echo $info
else echo $info >&2
fi
}

## Options

_nb_lines=15
_du_all_opt=a

OPTIND=1

while getopts ':hfdn:' opt
do
   case $opt in
      (h)
         _help 0
         return 0
         ;;
      (f)
         _only_files=1
         _du_all_opt=a
         ;;
      (d)
         _only_files=
         _du_all_opt=
         ;;
      (n)
         _nb_lines=$OPTARG
         ;;
      (\?)
         echo "Invalid option: -$OPTARG" >&2
         return 1
         ;;
   esac
done

shift $((OPTIND-1))

## Main

old_sort=1

if sort --help | grep -q human-numeric
then
   old_sort=0
   _du_arg=h
   _sort_arg=h
else
   _du_arg=
   _sort_arg=n
fi

_align=0
_files=()

# du's output
while read -r size date hour file
do

   # Directories only
   [[ -z $_du_all_opt ]] && [[ ! -d $file ]] && continue

   # Files only
   [[ -n $_only_files ]] && [[ -d $file ]] && continue

   if (( ! old_sort ))
   then
      # ex: 3.7M
      if [[ -n ${size%?} ]]
      then
         _size=${size%?}                 # 3.7
         unit=$(egrep -o '.$' <<< $size) # M
      # ex: 0
      else
         _size=$size
         unit=K
      fi

      case $unit in
         (K) unit=${_grn}${unit}${_res} ;;
         (M) unit=${_blu}${unit}${_res} ;;
         (G) unit=${_red}${unit}${_res} ;;
         (*) unit=${_Red}${unit}${_res}
      esac
   fi

   _file=${file#./}

   if (( ! old_sort ))
   then
      _len=${#_size}
      _files+=($_size $unit $date $hour $_file)
   else
      _len=${#size}
      _files+=($size $date $hour $_file)
   fi

   (( _len > _align )) && _align=$_len

done < <(du -S${_du_arg}${_du_all_opt}x --time --time-style=+'%d-%b-%y %H:%M' --exclude='.git' --exclude='vendor/bundle' --exclude='shared/bundle' -- $@ | sort -${_sort_arg}r | head -n$_nb_lines)

if (( ! old_sort ))
then
   for ((i = 1; i < ${#_files[@]} + 1; i=i+5))
   do
      # size unit date hour file
      printf "%${_align}s" ${_files[i]}
      echo -n "${_files[i+1]} "
      echo -n "${_files[i+2]} "
      echo -n "${_files[i+3]} "
      ls -d --color -- ${_files[i+4]}
   done
else
   for ((i = 1; i < ${#_files[@]} + 1; i=i+4))
   do
      # size date hour file
      printf "%${_align}s " ${_files[i]}
      echo -n "${_files[i+1]} "
      echo -n "${_files[i+2]} "
      ls -d --color -- ${_files[i+3]}
   done
fi
