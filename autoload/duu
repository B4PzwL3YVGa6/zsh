## Help
_help() {

local dot _N nb
cset -sfblue  dot .
cset -s       _N  N
cset -sfgreen nb 20

local files dirs both lines1 lines2
cset -fgreen << COLORS
files  # files only
dirs   # directories only
both   # files & directories
lines1 # lines of output (
lines2   by default)
COLORS

local info
# NB:
#    To get files only, a mixed output of both files and directories (du -a)
#    gets filtered. So with -f -n3, if the biggest 3 inodes are 2 directories
#    and one file, we get a single file despite using -n3
read -r -d $'\0' info << HELP
Usage:
   duu     ${files}
   duu -d  ${dirs}
   duu -a  ${both}
   duu -n${_N} ${lines1}${nb} ${lines2}

Note: ${dot} is used by default but a different directory can also be specified
HELP

if (($1 == 0))
then echo $info
else echo $info >&2
fi
}

## Options
local _nb_lines=20

# Show files only by default
local _only_files=1
local _du_all_opt=a

OPTIND=1

local opt
while getopts ':hadn:' opt
do
   case $opt in
      (h)
         _help 0
         return 0
         ;;
      (a)
         _only_files=
         _du_all_opt=a
         ;;
      (d)
         _only_files=
         _du_all_opt=
         ;;
      (n)
         _nb_lines=$OPTARG
         ;;
      (\?)
         echo "Invalid option: -$OPTARG" >&2
         return 1
         ;;
   esac
done

shift $((OPTIND-1))

## Main

local old_sort=1
local _du_arg _sort_arg

if sort --help | grep -q human-numeric
then
   old_sort=0
   _du_arg=h
   _sort_arg=h
else
   _du_arg=
   _sort_arg=n
fi

local _align=0
local _size unit _len _file _files
_files=()

local size date hour file
# du's output
while read -r size date hour file
do

   # Directories only
   [[ -z $_du_all_opt ]] && [[ ! -d $file ]] && continue

   # Files only
   [[ -n $_only_files ]] && [[ -d $file ]] && continue

   if (( ! old_sort ))
   then
      # ex: 3.7M
      if [[ -n ${size%?} ]]
      then
         _size=${size%?}                 # 3.7
         unit=$(egrep -o '.$' <<< $size) # M
      # ex: 0
      else
         _size=$size
         unit=K
      fi

      case $unit in
         (K) cset -fgreen unit $unit ;;
         (M) cset -fblue  unit $unit ;;
         (G) cset -fred   unit $unit ;;
         (*) cset -sfred  unit $unit
      esac
   fi

   _file=${file#./}

   if (( ! old_sort ))
   then
      _len=${#_size}
      _files+=($_size $unit $date $hour $_file)
   else
      _len=${#size}
      _files+=($size $date $hour $_file)
   fi

   (( _len > _align )) && _align=$_len

done < <(du -S${_du_arg}${_du_all_opt}x --time --time-style=+'%d-%b-%y %H:%M' --exclude='.git' --exclude='.hg' --exclude='.svn' --exclude='vendor/bundle' --exclude='shared/bundle' -- $@ | sort -${_sort_arg}r | head -n$_nb_lines)

if (( ! old_sort ))
then
   for ((i = 1; i < ${#_files[@]} + 1; i=i+5))
   do
      # size unit date hour file
      printf "%${_align}s" ${_files[i]}
      echo -n "${_files[i+1]} "
      echo -n "${_files[i+2]} "
      echo -n "${_files[i+3]} "
      ls -d --color=auto -- ${_files[i+4]}
   done | tee /tmp/duu
else
   for ((i = 1; i < ${#_files[@]} + 1; i=i+4))
   do
      # size date hour file
      printf "%${_align}s " ${_files[i]}
      echo -n "${_files[i+1]} "
      echo -n "${_files[i+2]} "
      ls -d --color=auto -- ${_files[i+3]}
   done | tee /tmp/duu
fi
